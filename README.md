# goit-algo-hw-04

# Аналіз алгоритмів сортування

## Огляд
Цей документ містить порівняльний аналіз трьох алгоритмів сортування: сортування вставками, сортування злиттям та Timsort. Аналіз проведено за допомогою емпіричних вимірювань часу виконання алгоритмів на масивах різного розміру.

## Алгоритми
1. **Сортування вставками**
   - Складність у гіршому випадку: \(O(n^2)\)
   - Найкраще використовується для маленьких або майже відсортованих даних.
2. **Сортування злиттям**
   - Складність: \(O(n \log n)\)
   - Добре скалюється для великих масивів.
3. **Timsort**
   - Складність у гіршому випадку: \(O(n \log n)\)
   - Стандартний алгоритм сортування в Python, оптимізований для різних типів даних.

## Методологія
Для кожного алгоритму було проведено середньостатистичний аналіз часу виконання на масивах розміром 100, 1000, 5000 та 10000 елементів. Для кожного розміру масиву було проведено 5 прогонів, результати яких були усереднені.

## Результати
| Розмір масиву | Сортування вставками (с) | Сортування злиттям (с) | Timsort (с) |
|---------------|--------------------------|------------------------|-------------|
| 100           | 0.00005                  | 0.00020                | 0.000007    |
| 1000          | 0.0093                   | 0.0025                 | 0.00018     |
| 5000          | 0.161                    | 0.019                  | 0.00088     |
| 10000         | 0.857                    | 0.041                  | 0.00248     |

## Висновки
Емпіричні дані підтверджують теоретичні оцінки складності алгоритмів. Сортування вставками є найменш ефективним на великих масивах, що відповідає його квадратичній складності. Сортування злиттям показало стабільніше скалювання, але Timsort виявився найшвидшим завдяки оптимізаціям та адаптивності до різних типів даних. Це робить Timsort ідеальним вибором для застосування в Python у більшості випадків.
